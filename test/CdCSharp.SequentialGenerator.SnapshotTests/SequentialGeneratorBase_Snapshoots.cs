using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Immutable;
using System.Text;

namespace CdCSharp.SequentialGenerator.SnapshotTests;

public class SequentialGeneratorBase_Snapshoots
{
    [Fact]
    public async Task GeneratedCodeMatchesExpectations()
    {
        // Arrange - Source code with test generators
        string source = @"
namespace TestApp
{
    public class Program 
    { 
        public static void Main() { }
    }
}";

        // Act - Create and execute compilation with generator
        SyntaxTree syntaxTree = CSharpSyntaxTree.ParseText(source);
        List<MetadataReference> references = GetDefaultReferences();

        CSharpCompilation compilation = CSharpCompilation.Create(
            "TestApp",
            new[] { syntaxTree },
            references,
            new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary));

        // Create and run generator
        TestSequentialGenerator generator = new();
        GeneratorDriver driver = CSharpGeneratorDriver.Create(generator);

        driver = driver.RunGeneratorsAndUpdateCompilation(
            compilation,
            out Compilation outputCompilation,
            out ImmutableArray<Diagnostic> diagnostics);

        // Assert - Validate results
        GeneratorDriverRunResult runResult = driver.GetRunResult();

        // Verify generated content using Verify
        await Verify(driver)
            .UseDirectory("Snapshots");
    }

    private static List<MetadataReference> GetDefaultReferences()
    {
        List<MetadataReference> references = [];

        string[] trustedAssemblies = ((string)AppContext.GetData("TRUSTED_PLATFORM_ASSEMBLIES")).Split(Path.PathSeparator);
        string[] requiredAssemblies = new[]
        {
            "System.Runtime",
            "System.Private.CoreLib",
            "Microsoft.CodeAnalysis",
            "Microsoft.CodeAnalysis.CSharp",
            "System.Collections",
            "System.Collections.Immutable",
        };

        foreach (string assembly in trustedAssemblies)
        {
            if (requiredAssemblies.Any(required =>
                Path.GetFileNameWithoutExtension(assembly).Equals(required, StringComparison.OrdinalIgnoreCase)))
            {
                references.Add(MetadataReference.CreateFromFile(assembly));
            }
        }

        // Add reference to assembly containing ISequentialGenerator
        System.Reflection.Assembly currentAssembly = typeof(ISequentialGenerator).Assembly;
        references.Add(MetadataReference.CreateFromFile(currentAssembly.Location));

        return references;
    }
}

// Test Generators Implementation
public class FirstTestGenerator : ISequentialGenerator
{
    public string Name => "First";

    public IncrementalValuesProvider<INamedTypeSymbol> ConfigureProvider(IncrementalGeneratorInitializationContext context)
    {
        // Simple provider that selects Program class
        return context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: (s, _) => s.IsKind(SyntaxKind.ClassDeclaration),
                transform: (ctx, _) =>
                {
                    ISymbol? symbol = ctx.SemanticModel.GetDeclaredSymbol(ctx.Node);
                    return symbol as INamedTypeSymbol;
                })
            .Where(t => t is not null)!;
    }

    public void Execute(SequentialGeneratorExecutionContext context)
    {
        context.AddSource("FirstGenerated.cs", SourceText.From(@"
namespace TestApp
{
    public class FirstGeneratedClass
    {
        public const string Message = ""First Generator"";
    }
}", Encoding.UTF8));
    }
}

public class SecondTestGenerator : ISequentialGenerator
{
    public string Name => "Second";

    public IncrementalValuesProvider<INamedTypeSymbol> ConfigureProvider(IncrementalGeneratorInitializationContext context)
    {
        // Simple provider that selects Program class
        return context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: (s, _) => s.IsKind(SyntaxKind.ClassDeclaration),
                transform: (ctx, _) =>
                {
                    ISymbol? symbol = ctx.SemanticModel.GetDeclaredSymbol(ctx.Node);
                    return symbol as INamedTypeSymbol;
                })
            .Where(t => t is not null)!;
    }

    public void Execute(SequentialGeneratorExecutionContext context)
    {
        // Access type generated by first generator
        INamedTypeSymbol? firstType = context.Compilation.GetTypeByMetadataName("TestApp.FirstGeneratedClass");

        context.AddSource("SecondGenerated.cs", SourceText.From(@"
namespace TestApp
{
    public class SecondGeneratedClass
    {
        public const string Message = ""Second Generator uses FirstGeneratedClass"";
    }
}", Encoding.UTF8));
    }

}

// Test Sequential Generator
public class TestSequentialGenerator : SequentialGeneratorBase
{
    public TestSequentialGenerator()
    {
        RegisterGenerator(new FirstTestGenerator());
        RegisterGenerator(new SecondTestGenerator());
    }
}